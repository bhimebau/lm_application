<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uEACos: ueaclib.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>ueaclib.c</h1><a href="ueaclib_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ueaclib.c --- </span>
<a name="l00002"></a>00002 <span class="comment"> * </span>
<a name="l00003"></a>00003 <span class="comment"> * Filename: ueaclib.c</span>
<a name="l00004"></a>00004 <span class="comment"> * Description: library of utilities needed to interact with the uEAC R002</span>
<a name="l00005"></a>00005 <span class="comment"> * Author: Bryce Himebaugh</span>
<a name="l00006"></a>00006 <span class="comment"> * Maintainer: </span>
<a name="l00007"></a>00007 <span class="comment"> * Created: Wed Nov  2 11:24:10 2005</span>
<a name="l00008"></a>00008 <span class="comment"> * Version: </span>
<a name="l00009"></a>00009 <span class="comment"> * Last-Updated: Tue Nov  8 11:46:20 2005</span>
<a name="l00010"></a>00010 <span class="comment"> *           By: Bryce Himebaugh</span>
<a name="l00011"></a>00011 <span class="comment"> *     Update #: 105</span>
<a name="l00012"></a>00012 <span class="comment"> * Keywords: </span>
<a name="l00013"></a>00013 <span class="comment"> * Compatibility: </span>
<a name="l00014"></a>00014 <span class="comment"> * </span>
<a name="l00015"></a>00015 <span class="comment"> */</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="comment">/* Commentary: </span>
<a name="l00018"></a>00018 <span class="comment"> * </span>
<a name="l00019"></a>00019 <span class="comment"> * </span>
<a name="l00020"></a>00020 <span class="comment"> * </span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* Change log:</span>
<a name="l00024"></a>00024 <span class="comment"> * </span>
<a name="l00025"></a>00025 <span class="comment"> * </span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">/* This program is free software; you can redistribute it and/or modify</span>
<a name="l00029"></a>00029 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00030"></a>00030 <span class="comment"> * the Free Software Foundation; either version 2, or (at your option)</span>
<a name="l00031"></a>00031 <span class="comment"> * any later version.</span>
<a name="l00032"></a>00032 <span class="comment"> * </span>
<a name="l00033"></a>00033 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<a name="l00034"></a>00034 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00035"></a>00035 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00036"></a>00036 <span class="comment"> * GNU General Public License for more details.</span>
<a name="l00037"></a>00037 <span class="comment"> * </span>
<a name="l00038"></a>00038 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00039"></a>00039 <span class="comment"> * along with this program; see the file COPYING.  If not, write to the</span>
<a name="l00040"></a>00040 <span class="comment"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<a name="l00041"></a>00041 <span class="comment"> * Boston, MA 02111-1307, USA.</span>
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment"> */</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="comment">/* Code: */</span>
<a name="l00046"></a>00046 <span class="comment">// Header file for the IUCS uEAC R002 hardware</span>
<a name="l00047"></a>00047 <span class="comment">// 6/1/05 initial version BH</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;msp430x16x.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;signal.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include "<a class="code" href="ueaclib_8h.html">ueaclib.h</a>"</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include "<a class="code" href="ueac_8h.html">ueac.h</a>"</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include "<a class="code" href="external__flash_8h.html">external_flash.h</a>"</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include "<a class="code" href="interpreter_8h.html">interpreter.h</a>"</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include "<a class="code" href="filter_8h.html">filter.h</a>"</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include "<a class="code" href="conversion_8h.html">conversion.h</a>"</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include "<a class="code" href="calibrate_8h.html">calibrate.h</a>"</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">extern</span> <span class="keywordtype">short</span> <a class="code" href="cal__table_8h.html#a0">dac_translation</a>[];
<a name="l00063"></a>00063 
<a name="l00064"></a><a class="code" href="ueaclib_8c.html#a0">00064</a> <span class="preprocessor">#define DELTA 900                   // target DCO = DELTA*(4096) = 3686400</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>
<a name="l00066"></a>00066 <span class="comment">// Function Prototypes</span>
<a name="l00067"></a>00067 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a3">init_pins</a>(<span class="keywordtype">void</span>);
<a name="l00068"></a>00068 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a4">init_spi_0</a> (<span class="keywordtype">void</span>);
<a name="l00069"></a>00069 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a5">init_serial_1</a> (<span class="keywordtype">void</span>);
<a name="l00070"></a>00070 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a6">init_timer_a</a>(<span class="keywordtype">void</span>);
<a name="l00071"></a>00071 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a7">init_dac</a>(<span class="keywordtype">void</span>);
<a name="l00072"></a>00072 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a8">init_a2d</a>(<span class="keywordtype">void</span>);
<a name="l00073"></a>00073 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a9">start_a2d_converter</a> (<span class="keywordtype">void</span>);
<a name="l00074"></a>00074 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a10">Set_DCO</a> (<span class="keywordtype">void</span>);
<a name="l00075"></a>00075 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a11">clear_latches</a>(<span class="keywordtype">void</span>);
<a name="l00076"></a>00076 <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a12">system_reset</a>(<span class="keywordtype">void</span>); 
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="ueaclib_8h.html#a6">00079</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a13">init_sys</a>(<span class="keywordtype">void</span>) {
<a name="l00080"></a>00080   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00081"></a>00081   WDTCTL = WDTPW + WDTHOLD;    <span class="comment">// Stop watchdog</span>
<a name="l00082"></a>00082   <a class="code" href="ueaclib_8c.html#a3">init_pins</a>();                 <span class="comment">// Setup the discrete I/O - important to enable 8Mhz crystal </span>
<a name="l00083"></a>00083   <span class="keywordflow">for</span> (i = 0xFFFF;i&gt;0;i--);    <span class="comment">// Delay for XTAL and oscillator to fire up and settle</span>
<a name="l00084"></a>00084   <a class="code" href="ueaclib_8c.html#a10">Set_DCO</a>();                   <span class="comment">// calibrate DCO using the 32.768Khz crystal to 3.686400 Mhz  </span>
<a name="l00085"></a>00085   <a class="code" href="ueaclib_8c.html#a4">init_spi_0</a>();
<a name="l00086"></a>00086   <a class="code" href="ueaclib_8c.html#a5">init_serial_1</a>();             <span class="comment">// initialize USB virtual serial port</span>
<a name="l00087"></a>00087   <a class="code" href="ueaclib_8c.html#a6">init_timer_a</a>();              
<a name="l00088"></a>00088   <a class="code" href="ueaclib_8c.html#a7">init_dac</a>();
<a name="l00089"></a>00089   <a class="code" href="ueaclib_8c.html#a8">init_a2d</a>();
<a name="l00090"></a>00090   <a class="code" href="ueaclib_8c.html#a11">clear_latches</a>();
<a name="l00091"></a>00091   _EINT();                     <span class="comment">// Global interrupt enable</span>
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="ueaclib_8c.html#a12">00094</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a12">system_reset</a>(<span class="keywordtype">void</span>) {
<a name="l00095"></a>00095   _DINT();
<a name="l00096"></a>00096   WDTCTL = WDTPW|WDTCNTCL|WDTIS_3;  <span class="comment">// start the watchdog, SMCLK ticks until reset </span>
<a name="l00097"></a>00097   P4OUT=0x8F;
<a name="l00098"></a>00098   <span class="keywordflow">while</span> (1);                        <span class="comment">// wedge here until the dog resets the core</span>
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00101"></a><a class="code" href="ueaclib_8c.html#a11">00101</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a11">clear_latches</a>(<span class="keywordtype">void</span>) {
<a name="l00102"></a>00102   P1OUT=0x00;
<a name="l00103"></a>00103   P5OUT=0x3F;
<a name="l00104"></a>00104   P5OUT=0x00;
<a name="l00105"></a>00105 }
<a name="l00106"></a>00106 
<a name="l00107"></a><a class="code" href="ueaclib_8c.html#a10">00107</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a10">Set_DCO</a> (<span class="keywordtype">void</span>) { 
<a name="l00108"></a>00108   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Compare, Oldcapture = 0;
<a name="l00109"></a>00109   CCTL0 = 0x0000;                       <span class="comment">// this too - see next comment</span>
<a name="l00110"></a>00110   CCTL1 = 0x0000;                       <span class="comment">// see if this fixes the clock cal issue</span>
<a name="l00111"></a>00111   CCTL2 = 0x0000;
<a name="l00112"></a>00112   CCTL2 = CCIS0 + CM0 + CAP;            <span class="comment">// Define CCR2, CAP, ACLK</span>
<a name="l00113"></a>00113   TACTL = TASSEL1 + TACLR + MC1;        <span class="comment">// SMCLK, continous mode</span>
<a name="l00114"></a>00114   <span class="keywordflow">while</span> (1) {
<a name="l00115"></a>00115     <span class="keywordflow">while</span> ((CCTL2 &amp; CCIFG) != CCIFG);   <span class="comment">// Wait until capture occured!</span>
<a name="l00116"></a>00116     CCTL2 &amp;= ~CCIFG;                    <span class="comment">// Capture occured, clear flag</span>
<a name="l00117"></a>00117     Compare = CCR2;                     <span class="comment">// Get current captured SMCLK</span>
<a name="l00118"></a>00118     Compare = Compare - Oldcapture;     <span class="comment">// SMCLK difference</span>
<a name="l00119"></a>00119     Oldcapture = CCR2;                  <span class="comment">// Save current captured SMCLK</span>
<a name="l00120"></a>00120     <span class="keywordflow">if</span> (<a class="code" href="ueaclib_8c.html#a0">DELTA</a> == Compare) {
<a name="l00121"></a>00121       <span class="keywordflow">break</span>;                            <span class="comment">// if equal, leave "while(1)"</span>
<a name="l00122"></a>00122     }
<a name="l00123"></a>00123     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ueaclib_8c.html#a0">DELTA</a> &lt; Compare) {         <span class="comment">// DCO is too fast, slow it down</span>
<a name="l00124"></a>00124       DCOCTL--;
<a name="l00125"></a>00125       <span class="keywordflow">if</span> (DCOCTL == 0xFF) {             <span class="comment">// Did DCO roll under?</span>
<a name="l00126"></a>00126         BCSCTL1--;                      <span class="comment">// Select next lower RSEL</span>
<a name="l00127"></a>00127       }
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129     <span class="keywordflow">else</span> {                      
<a name="l00130"></a>00130       DCOCTL++;
<a name="l00131"></a>00131       <span class="keywordflow">if</span> (DCOCTL == 0x00) {             <span class="comment">// Did DCO roll over?</span>
<a name="l00132"></a>00132         BCSCTL1++;                      <span class="comment">// Select next higher RSEL</span>
<a name="l00133"></a>00133       }
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135   }  
<a name="l00136"></a>00136   CCTL2 = 0;                              <span class="comment">// Stop CCR2 function</span>
<a name="l00137"></a>00137   TACTL = 0;                              <span class="comment">// Stop Timer_A</span>
<a name="l00138"></a>00138 }
<a name="l00139"></a>00139 
<a name="l00140"></a><a class="code" href="ueaclib_8c.html#a4">00140</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a4">init_spi_0</a> (<span class="keywordtype">void</span>) {
<a name="l00141"></a>00141   UCTL0 |= SWRST;                <span class="comment">// Place USART into RESET </span>
<a name="l00142"></a>00142   UCTL0  = CHAR|SYNC|MM|SWRST;   <span class="comment">// 8-bit,SPI,Master,Hold Module in RESET</span>
<a name="l00143"></a>00143   UTCTL0 = CKPH|SSEL1|SSEL0|STC; <span class="comment">// falling edge out,SMCLK,3-pin SPI (Works for LTC Parts)</span>
<a name="l00144"></a>00144   <span class="comment">// UTCTL0 = CKPL|SSEL1|SSEL0|STC; // falling edge out,SMCLK,3-pin SPI (Works for AT parts)</span>
<a name="l00145"></a>00145   <span class="comment">// LTC1660 DAC can handle a 5Mhz SCLK</span>
<a name="l00146"></a>00146   <span class="comment">// AT45DB041 Flash can handle 20Mhz SCLK </span>
<a name="l00147"></a>00147   UBR00  = 0x02;                 <span class="comment">// Run at SMCLK/2 - 8Mhz/2=4Mhz for normal operation</span>
<a name="l00148"></a>00148   UBR10  = 0x00;                 <span class="comment">// Upper half of SCLK control </span>
<a name="l00149"></a>00149   ME1    = USPIE0;               <span class="comment">// Enable the SPI module for UART0</span>
<a name="l00150"></a>00150   UMCTL0 = 0x00;                 <span class="comment">// Modulation control not used by SPI set to 0 according to User's Guide</span>
<a name="l00151"></a>00151   UCTL0 &amp;= ~SWRST;               <span class="comment">// release USART from RESET </span>
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a><a class="code" href="ueaclib_8h.html#a11">00154</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="external__flash_8h.html#a5">send_spi_byte</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data_byte) {
<a name="l00155"></a>00155   TXBUF0 = data_byte;        <span class="comment">// buffer 1 write  </span>
<a name="l00156"></a>00156   <span class="keywordflow">while</span>(!(UTCTL0&amp;0x01));     <span class="comment">// wait until transmitter empty</span>
<a name="l00157"></a>00157   <span class="keywordflow">return</span>(RXBUF0);            <span class="comment">// return any received data</span>
<a name="l00158"></a>00158                              <span class="comment">// No data returned from DAC</span>
<a name="l00159"></a>00159                              <span class="comment">// SPI flash returns read data</span>
<a name="l00160"></a>00160 }
<a name="l00161"></a>00161 
<a name="l00162"></a><a class="code" href="ueaclib_8c.html#a5">00162</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a5">init_serial_1</a> (<span class="keywordtype">void</span>) {
<a name="l00163"></a>00163   <span class="keywordtype">char</span> temp;
<a name="l00164"></a>00164   <span class="comment">// Data Comm Port - Connected to FT2232 Port A</span>
<a name="l00165"></a>00165   UCTL1 = CHAR + SWRST;
<a name="l00166"></a>00166   UTCTL1 = SSEL1 + SSEL0;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="comment">// 19.2k init (3.686400 Mhz Clock)</span>
<a name="l00169"></a>00169   UBR01=0xC0; 
<a name="l00170"></a>00170   UBR11=0x00;
<a name="l00171"></a>00171   UMCTL1=0x00; 
<a name="l00172"></a>00172   ME2 = 0x30;
<a name="l00173"></a>00173   UCTL1 = CHAR;
<a name="l00174"></a>00174   temp=RXBUF1;  <span class="comment">// Flush the RX buffer </span>
<a name="l00175"></a>00175   temp=RXBUF1;  
<a name="l00176"></a>00176 }
<a name="l00177"></a>00177     
<a name="l00178"></a><a class="code" href="ueaclib_8h.html#a9">00178</a> <span class="keywordtype">int</span> <a class="code" href="ueaclib_8c.html#a15">putchar</a>(<span class="keywordtype">int</span> in_char){
<a name="l00179"></a>00179   <span class="keywordflow">while</span> (!(IFG2&amp;UTXIFG1));
<a name="l00180"></a>00180   TXBUF1=in_char;
<a name="l00181"></a>00181   <span class="keywordflow">return</span>(0);
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a><a class="code" href="ueaclib_8h.html#a10">00184</a> <span class="keywordtype">char</span> <a class="code" href="ueaclib_8c.html#a16">getchar</a>(<span class="keywordtype">void</span>) {
<a name="l00185"></a>00185   <span class="keywordtype">char</span> rx_data;
<a name="l00186"></a>00186   <span class="keywordflow">while</span> (!(IFG2&amp;URXIFG1));
<a name="l00187"></a>00187   rx_data= RXBUF1;
<a name="l00188"></a>00188   <span class="keywordflow">return</span> (rx_data);
<a name="l00189"></a>00189 }
<a name="l00190"></a>00190 
<a name="l00191"></a><a class="code" href="ueaclib_8c.html#a3">00191</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a3">init_pins</a>(<span class="keywordtype">void</span>) {
<a name="l00206"></a>00206   P1SEL = 0x00;
<a name="l00207"></a>00207   P1OUT = 0x00;
<a name="l00208"></a>00208   P1DIR = 0xFF;
<a name="l00209"></a>00209 
<a name="l00224"></a>00224   P2SEL = 0x00;
<a name="l00225"></a>00225   P2OUT = 0x00;
<a name="l00226"></a>00226   P2DIR = 0x5B;
<a name="l00227"></a>00227 
<a name="l00242"></a>00242   P3SEL = 0xFE;
<a name="l00243"></a>00243   P3OUT = 0x00;
<a name="l00244"></a>00244   P3DIR = 0x5B;
<a name="l00245"></a>00245 
<a name="l00260"></a>00260   P4SEL = 0x00;
<a name="l00261"></a>00261   P4OUT = 0x8F;   
<a name="l00262"></a>00262   P4DIR = 0xFF; 
<a name="l00277"></a>00277   P5SEL = 0x00;
<a name="l00278"></a>00278   P5OUT = 0x00;
<a name="l00279"></a>00279   P5DIR = 0xFF; 
<a name="l00280"></a>00280 
<a name="l00295"></a>00295   P6SEL = 0x5F;
<a name="l00296"></a>00296   P6OUT = 0x00;
<a name="l00297"></a>00297   P6DIR = 0xA0; 
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a><a class="code" href="ueaclib_8c.html#a6">00300</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a6">init_timer_a</a>(<span class="keywordtype">void</span>) {
<a name="l00301"></a>00301   <span class="comment">// SMCLK SOURCE (3.686400Mhz)</span>
<a name="l00302"></a>00302   <span class="comment">// Timer in Continuous Mode </span>
<a name="l00303"></a>00303   <span class="comment">// Clear the timer register (TAR)</span>
<a name="l00304"></a>00304   <span class="comment">// Compare 1 used as main time base at 1.25mS. </span>
<a name="l00305"></a>00305   TACTL=TASSEL1|MC1|TACLR;  <span class="comment">// Timer a sourced from 3.686400 Mhz SMCLK, continuous mode</span>
<a name="l00306"></a>00306   TACCR0=0x900;             <span class="comment">// 100uS interrupt rate</span>
<a name="l00307"></a>00307   TACCTL0=CCIE;             <span class="comment">// Enable the timer interrupt</span>
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00310"></a><a class="code" href="ueaclib_8c.html#a7">00310</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a7">init_dac</a>(<span class="keywordtype">void</span>) {
<a name="l00311"></a>00311   <span class="comment">// Dac 0 Controls Sources </span>
<a name="l00312"></a>00312   <span class="comment">// Dac 1 Controls Sinks</span>
<a name="l00313"></a>00313   <span class="comment">// Parameters</span>
<a name="l00314"></a>00314   <span class="comment">// [14-13] DAC12SREFx (11) Use VeREF+-&gt;3.3V </span>
<a name="l00315"></a>00315   <span class="comment">// [12] DAC12RES (0) 12-Bit Resolution  </span>
<a name="l00316"></a>00316   <span class="comment">// [11-10] DAC12LSELx (00) Load DAC on write to the DAC12_0DAT register</span>
<a name="l00317"></a>00317   <span class="comment">// [9] DAC12CALON (1) Calibration active, poll until this bit is clear </span>
<a name="l00318"></a>00318   <span class="comment">// [8] DAC12IR (1) Input range = 1x</span>
<a name="l00319"></a>00319   <span class="comment">// [7-5] DAC12AMPx (111) High Speed, High Current </span>
<a name="l00320"></a>00320   <span class="comment">// [4] DAC12DF (0) Straight Binary </span>
<a name="l00321"></a>00321   <span class="comment">// [3] DAC12IE (0) Interrupt Disabled</span>
<a name="l00322"></a>00322   <span class="comment">// [2] DAC12IFG (x) Interrupt flag</span>
<a name="l00323"></a>00323   <span class="comment">// [1] DAC12ENC (1) Enable DAC conversion </span>
<a name="l00324"></a>00324   <span class="comment">// [0] DAC12GRP (0) Channel grouping disabled </span>
<a name="l00325"></a>00325   DAC12_0CTL = DAC12SREF1|DAC12SREF0|DAC12CALON|DAC12IR|DAC12AMP2|DAC12AMP1|DAC12AMP0|DAC12ENC;
<a name="l00326"></a>00326   <span class="keywordflow">while</span> (DAC12_0CTL&amp;DAC12CALON);  <span class="comment">// spin here until cal complete</span>
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00350"></a><a class="code" href="ueaclib_8c.html#a8">00350</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a8">init_a2d</a> (<span class="keywordtype">void</span>) {
<a name="l00351"></a>00351   <span class="comment">// ADC12 Parameters</span>
<a name="l00352"></a>00352   <span class="comment">// Sample Hold Time - 16 clocks </span>
<a name="l00355"></a>00355 <span class="comment"></span>  ADC12CTL0 = SHT1_2|SHT0_2|MSC|REF2_5V|REFON|ADC12ON; <span class="comment">// sampling time set to 3.2uS </span>
<a name="l00356"></a>00356   ADC12CTL1 = SHP|CONSEQ0;                             <span class="comment">// sample sequence of channels and then stop </span>
<a name="l00357"></a>00357   ADC12MCTL0 =  SREF_2|INCH_0;                         <span class="comment">// Use Avcc (3.3V) as the reference, channels (0-7)   </span>
<a name="l00358"></a>00358   ADC12MCTL1 =  SREF_2|INCH_1;                         <span class="comment">// Use Avcc (3.3V) as the reference, channels (8-15)   </span>
<a name="l00359"></a>00359   ADC12MCTL2 =  SREF_2|INCH_2;                         <span class="comment">// Use Avcc (3.3V) as the reference, channels (16-23)   </span>
<a name="l00360"></a>00360   ADC12MCTL3 =  EOS|SREF_2|INCH_3;                     <span class="comment">// Use Avcc (3.3V) as the reference, channels (24)    </span>
<a name="l00361"></a>00361 }
<a name="l00362"></a>00362 
<a name="l00363"></a><a class="code" href="ueaclib_8c.html#a9">00363</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a9">start_a2d_converter</a>(<span class="keywordtype">void</span>) {
<a name="l00364"></a>00364   ADC12CTL0|=ENC|ADC12SC;                    <span class="comment">// start the converter </span>
<a name="l00365"></a>00365 }  
<a name="l00366"></a>00366 
<a name="l00367"></a><a class="code" href="ueaclib_8c.html#a17">00367</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a17">stop_a2d_converter</a>(<span class="keywordtype">void</span>) {
<a name="l00368"></a>00368   ADC12CTL0&amp;=~ENC;                           <span class="comment">// stop the converter </span>
<a name="l00369"></a>00369 }  
<a name="l00370"></a>00370 
<a name="l00371"></a><a class="code" href="ueaclib_8h.html#a17">00371</a> <span class="keywordtype">int</span> <a class="code" href="ueaclib_8c.html#a18">wait_a2d_busy</a>(<span class="keywordtype">void</span>) {
<a name="l00372"></a>00372   <span class="keywordtype">int</span> count=0;
<a name="l00373"></a>00373   <span class="keywordflow">while</span> (ADC12CTL1&amp;ADC12BUSY) count++;
<a name="l00374"></a>00374   <span class="keywordflow">return</span> count;
<a name="l00375"></a>00375 }
<a name="l00376"></a>00376 
<a name="l00377"></a><a class="code" href="ueaclib_8h.html#a18">00377</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a19">write_analog_mux</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> select) {
<a name="l00378"></a>00378   select&amp;=0x07;   <span class="comment">// clamp the input to 7 </span>
<a name="l00379"></a>00379   select&lt;&lt;=4;     <span class="comment">// shift to align with bits 6-4 (mux select bits)</span>
<a name="l00380"></a>00380   P4OUT&amp;=0x8F;    <span class="comment">// clear the mux select bits</span>
<a name="l00381"></a>00381   P4OUT|=select;  <span class="comment">// "or" in the new select value</span>
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 
<a name="l00384"></a><a class="code" href="ueaclib_8h.html#a13">00384</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a20">write_current</a>(<span class="keywordtype">int</span> <a class="code" href="structchannel.html">channel</a>,<span class="keywordtype">int</span> value_uA) {
<a name="l00385"></a>00385   <span class="keywordflow">if</span> (value_uA&gt;200) value_uA=200;
<a name="l00386"></a>00386   <span class="keywordflow">if</span> (value_uA&lt;-200) value_uA=-200;
<a name="l00387"></a>00387   <span class="keywordflow">if</span> (value_uA==0) {
<a name="l00388"></a>00388     <a class="code" href="ueaclib_8c.html#a21">write_dac</a>(channel,(<a class="code" href="cal__table_8h.html#a0">dac_translation</a>[200]+<a class="code" href="global_8c.html#a1">ueac_state</a>.<a class="code" href="structueac.html#o3">pin_cal</a>[channel].<a class="code" href="structcal.html#o1">i_zero_offset</a>));
<a name="l00389"></a>00389   }
<a name="l00390"></a>00390   <span class="keywordflow">else</span> {
<a name="l00391"></a>00391     <a class="code" href="ueaclib_8c.html#a21">write_dac</a>(channel,<a class="code" href="cal__table_8h.html#a0">dac_translation</a>[200-value_uA]+<a class="code" href="global_8c.html#a1">ueac_state</a>.<a class="code" href="structueac.html#o3">pin_cal</a>[channel].<a class="code" href="structcal.html#o0">i_200uA_offset</a>);
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393 }
<a name="l00394"></a>00394 
<a name="l00395"></a><a class="code" href="ueaclib_8h.html#a12">00395</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a21">write_dac</a>(<span class="keywordtype">int</span> <a class="code" href="structchannel.html">channel</a>,<span class="keywordtype">int</span> value) {
<a name="l00396"></a>00396   <span class="comment">// write_dac(channel,value)</span>
<a name="l00397"></a>00397   <span class="comment">// channel = 0-24 where the channels are the control voltages for the current sources. The current </span>
<a name="l00398"></a>00398   <span class="comment">// sources are labeled starting at the top left corner as follows.</span>
<a name="l00399"></a>00399   <span class="comment">//  0  1  2  3  4</span>
<a name="l00400"></a>00400   <span class="comment">//  5  6  7  8  9</span>
<a name="l00401"></a>00401   <span class="comment">// 10 11 12 13 14</span>
<a name="l00402"></a>00402   <span class="comment">// 15 16 17 18 19</span>
<a name="l00403"></a>00403   <span class="comment">// 20 21 22 23 24</span>
<a name="l00404"></a>00404   <span class="comment">//</span>
<a name="l00405"></a>00405   <span class="comment">// Value = 0-1023 (10-bit) where the number represents a control voltage that is 0-3.3v. Each bit represents </span>
<a name="l00406"></a>00406   <span class="comment">// a voltage of 3.3v/1023 or 3.22mV. </span>
<a name="l00407"></a>00407   <span class="comment">//</span>
<a name="l00408"></a>00408   <span class="comment">// Hardware Note: Channels 0-23 are implemented by external SPI octal dacs (Linear LTC1660 components). Channel </span>
<a name="l00409"></a>00409   <span class="comment">// 24 is implemented using DAC0 on the MSP430 </span>
<a name="l00410"></a>00410   <span class="comment">// </span>
<a name="l00411"></a>00411   <span class="comment">// Initial Version BH 11/1/05</span>
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="keywordflow">if</span> (channel &lt; 8) {
<a name="l00414"></a>00414     P4OUT&amp;=~0x01;                                   <span class="comment">// assert the proper chip select</span>
<a name="l00415"></a>00415     channel++;                                      <span class="comment">// increment the channel number LTC1660 channels run from 1-8   </span>
<a name="l00416"></a>00416   }           
<a name="l00417"></a>00417   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel &lt; 16) {
<a name="l00418"></a>00418     P4OUT&amp;=~0x02;                                   <span class="comment">// assert the proper chip select</span>
<a name="l00419"></a>00419     channel-=7;                                     <span class="comment">// bring channel number into range 1-8</span>
<a name="l00420"></a>00420   } 
<a name="l00421"></a>00421   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel &lt; 24) {
<a name="l00422"></a>00422     P4OUT&amp;=~0x04;                                   <span class="comment">// assert the proper chip select</span>
<a name="l00423"></a>00423     channel-=15;                                    <span class="comment">// bring channel number into range 1-8</span>
<a name="l00424"></a>00424   }
<a name="l00425"></a>00425   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel == 24) {
<a name="l00426"></a>00426     DAC12_0DAT=value&lt;&lt;2;                            <span class="comment">// Shift up to a 12-bit number and write to the MSP430 DAC0 </span>
<a name="l00427"></a>00427     <span class="keywordflow">return</span>;                                         <span class="comment">// This is all to do for the MSP430 DAC case, exit...</span>
<a name="l00428"></a>00428   }
<a name="l00429"></a>00429   <span class="keywordflow">else</span> {                                            <span class="comment">// channel number provided is too large, exit... </span>
<a name="l00430"></a>00430     <span class="keywordflow">return</span>;
<a name="l00431"></a>00431   }
<a name="l00432"></a>00432   value=(value&amp;0x03FF)&lt;&lt;2;                          <span class="comment">// mask and shift the value to align properly in the dac sentence</span>
<a name="l00433"></a>00433   channel&lt;&lt;=4;
<a name="l00434"></a>00434   *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;value)+1)|=((<span class="keywordtype">unsigned</span> char) channel); <span class="comment">// "or" in the channel number to the value data</span>
<a name="l00435"></a>00435   <a class="code" href="external__flash_8h.html#a5">send_spi_byte</a>(*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;value)+1));             <span class="comment">// send the high byte </span>
<a name="l00436"></a>00436   <a class="code" href="external__flash_8h.html#a5">send_spi_byte</a>(*((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;value));                 <span class="comment">// send the high byte </span>
<a name="l00437"></a>00437   P4OUT|=0x0F;                                                <span class="comment">// deassert all of the spi dac chip selects   </span>
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 
<a name="l00440"></a><a class="code" href="ueaclib_8c.html#a1">00440</a> <span class="preprocessor">#define PWM_COUNT_MASK 0x1F</span>
<a name="l00441"></a><a class="code" href="ueaclib_8h.html#a20">00441</a> <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a22">led_pwm</a> (<span class="keywordtype">int</span> enable) {
<a name="l00442"></a>00442   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> counter=0;
<a name="l00443"></a>00443   <span class="keywordflow">if</span> (enable) {
<a name="l00444"></a>00444     counter++;
<a name="l00445"></a>00445     counter&amp;=<a class="code" href="ueaclib_8c.html#a1">PWM_COUNT_MASK</a>; 
<a name="l00446"></a>00446     <span class="keywordflow">if</span> (!counter) {
<a name="l00447"></a>00447       P1OUT=0xFF;
<a name="l00448"></a>00448       P5OUT=0x07;
<a name="l00449"></a>00449       P5OUT=0;
<a name="l00450"></a>00450       P2OUT|=0x01;
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452     P1OUT=0xFF;
<a name="l00453"></a>00453     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[0]) P1OUT&amp;=~0x01;
<a name="l00454"></a>00454     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[1]) P1OUT&amp;=~0x02;
<a name="l00455"></a>00455     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[2]) P1OUT&amp;=~0x04;
<a name="l00456"></a>00456     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[3]) P1OUT&amp;=~0x08;
<a name="l00457"></a>00457     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[4]) P1OUT&amp;=~0x10;
<a name="l00458"></a>00458     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[5]) P1OUT&amp;=~0x20;
<a name="l00459"></a>00459     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[6]) P1OUT&amp;=~0x40;
<a name="l00460"></a>00460     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[7]) P1OUT&amp;=~0x80;
<a name="l00461"></a>00461     P5OUT=0x01;
<a name="l00462"></a>00462     P5OUT=0x00;
<a name="l00463"></a>00463     P1OUT=0xFF;
<a name="l00464"></a>00464     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[8]) P1OUT&amp;=~0x01;
<a name="l00465"></a>00465     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[9]) P1OUT&amp;=~0x02;
<a name="l00466"></a>00466     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[10]) P1OUT&amp;=~0x04;
<a name="l00467"></a>00467     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[11]) P1OUT&amp;=~0x08;
<a name="l00468"></a>00468     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[12]) P1OUT&amp;=~0x10;
<a name="l00469"></a>00469     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[13]) P1OUT&amp;=~0x20;
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[14]) P1OUT&amp;=~0x40;
<a name="l00471"></a>00471     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[15]) P1OUT&amp;=~0x80;
<a name="l00472"></a>00472     P5OUT=0x02;
<a name="l00473"></a>00473     P5OUT=0x00;
<a name="l00474"></a>00474     P1OUT=0xFF;
<a name="l00475"></a>00475     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[16]) P1OUT&amp;=~0x01;
<a name="l00476"></a>00476     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[17]) P1OUT&amp;=~0x02;
<a name="l00477"></a>00477     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[18]) P1OUT&amp;=~0x04;
<a name="l00478"></a>00478     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[19]) P1OUT&amp;=~0x08;
<a name="l00479"></a>00479     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[20]) P1OUT&amp;=~0x10;
<a name="l00480"></a>00480     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[21]) P1OUT&amp;=~0x20;
<a name="l00481"></a>00481     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[22]) P1OUT&amp;=~0x40;
<a name="l00482"></a>00482     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[23]) P1OUT&amp;=~0x80;
<a name="l00483"></a>00483     P5OUT=0x04;
<a name="l00484"></a>00484     P5OUT=0x00;
<a name="l00485"></a>00485     <span class="keywordflow">if</span> (counter&gt;=<a class="code" href="global_8c.html#a7">high_time_limit</a>[24]) P2OUT&amp;=~0x01;
<a name="l00486"></a>00486   }
<a name="l00487"></a>00487 }
<a name="l00488"></a>00488 
<a name="l00489"></a><a class="code" href="ueaclib_8h.html#a21">00489</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a23">clear_led_screen</a> (<span class="keywordtype">void</span>) {
<a name="l00490"></a>00490   P1OUT=0;
<a name="l00491"></a>00491   P5OUT=0x07;
<a name="l00492"></a>00492   P5OUT=0;
<a name="l00493"></a>00493   P2OUT&amp;=~0x01;
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 
<a name="l00497"></a><a class="code" href="ueaclib_8h.html#a14">00497</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a24">write_led</a> (<span class="keywordtype">int</span> <a class="code" href="structchannel.html">channel</a>, <span class="keywordtype">int</span> enable) {
<a name="l00498"></a>00498   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> led_state = 0x00000000;
<a name="l00499"></a>00499   <span class="keywordflow">if</span> (enable) {
<a name="l00500"></a>00500     <span class="keywordflow">if</span> (channel&lt;8) {
<a name="l00501"></a>00501       *((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state) |= 0x01&lt;&lt;channel;       <span class="comment">// Save the new state of the LED in led_state</span>
<a name="l00502"></a>00502       P1OUT=*((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state);                  <span class="comment">// Place the relevant byte of led_state on the latch bus </span>
<a name="l00503"></a>00503       P5OUT|=0x01;                                            <span class="comment">// strobe the chip select for the target latch</span>
<a name="l00504"></a>00504       P5OUT&amp;=~0x01;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel&lt;16) {
<a name="l00507"></a>00507       channel-=8;
<a name="l00508"></a>00508       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+1) |= 0x01&lt;&lt;channel;  
<a name="l00509"></a>00509       P1OUT=*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+1);  
<a name="l00510"></a>00510       P5OUT=0x02;
<a name="l00511"></a>00511       P5OUT&amp;=~0x02;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00512"></a>00512     }
<a name="l00513"></a>00513     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel&lt;24) {
<a name="l00514"></a>00514       channel-=16;
<a name="l00515"></a>00515       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+2) |= 0x01&lt;&lt;channel;  
<a name="l00516"></a>00516       P1OUT=*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+2);  
<a name="l00517"></a>00517       P5OUT=0x04;
<a name="l00518"></a>00518       P5OUT&amp;=~0x04;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00519"></a>00519     }
<a name="l00520"></a>00520     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel==24) {
<a name="l00521"></a>00521       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+3) |= 0x01;  
<a name="l00522"></a>00522       P2OUT|=0x01;
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524   }
<a name="l00525"></a>00525   <span class="keywordflow">else</span> {
<a name="l00526"></a>00526     <span class="keywordflow">if</span> (channel&lt;8) {
<a name="l00527"></a>00527       *((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state) &amp;= ~(0x01&lt;&lt;channel);  
<a name="l00528"></a>00528       P1OUT=*((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state);  
<a name="l00529"></a>00529       P5OUT=0x01;
<a name="l00530"></a>00530       P5OUT&amp;=~0x01;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00531"></a>00531     }
<a name="l00532"></a>00532     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel&lt;16) {
<a name="l00533"></a>00533       channel-=8;
<a name="l00534"></a>00534       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+1) &amp;= ~(0x01&lt;&lt;channel);  
<a name="l00535"></a>00535       P1OUT=*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+1);  
<a name="l00536"></a>00536       P5OUT=0x02;
<a name="l00537"></a>00537       P5OUT&amp;=~0x02;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel&lt;24) {
<a name="l00540"></a>00540       channel-=16;
<a name="l00541"></a>00541       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+2) &amp;= ~(0x01&lt;&lt;channel);  
<a name="l00542"></a>00542       P1OUT=*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+2);  
<a name="l00543"></a>00543       P5OUT=0x04;
<a name="l00544"></a>00544       P5OUT&amp;=~0x04;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel==24) {
<a name="l00547"></a>00547       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;led_state)+3) &amp;= 0xFE;  
<a name="l00548"></a>00548       P2OUT&amp;=0xFE;
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550   }
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a><a class="code" href="ueaclib_8h.html#a15">00553</a> <span class="keywordtype">void</span> <a class="code" href="ueaclib_8c.html#a25">write_lla</a> (<span class="keywordtype">int</span> <a class="code" href="structchannel.html">channel</a>, <span class="keywordtype">int</span> enable) {
<a name="l00554"></a>00554   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lla_state = 0x00000000;
<a name="l00555"></a>00555   <span class="keywordflow">if</span> (enable) {
<a name="l00556"></a>00556     <span class="keywordflow">if</span> (channel&lt;8) {
<a name="l00557"></a>00557       *((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state) |= 0x01&lt;&lt;channel;       <span class="comment">// Save the new state of the LED in lla_state</span>
<a name="l00558"></a>00558       P1OUT=*((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state);                  <span class="comment">// Place the relevant byte of lla_state on the latch bus </span>
<a name="l00559"></a>00559       P5OUT|=0x08;                                            <span class="comment">// strobe the chip select for the target latch</span>
<a name="l00560"></a>00560       P5OUT&amp;=~0x08;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel&lt;16) {
<a name="l00563"></a>00563       channel-=8;
<a name="l00564"></a>00564       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+1) |= 0x01&lt;&lt;channel;  
<a name="l00565"></a>00565       P1OUT=*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+1);  
<a name="l00566"></a>00566       P5OUT=0x10;
<a name="l00567"></a>00567       P5OUT&amp;=~0x10;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00568"></a>00568     }
<a name="l00569"></a>00569     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel&lt;24) {
<a name="l00570"></a>00570       channel-=16;
<a name="l00571"></a>00571       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+2) |= 0x01&lt;&lt;channel;  
<a name="l00572"></a>00572       P1OUT=*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+2);  
<a name="l00573"></a>00573       P5OUT=0x20;
<a name="l00574"></a>00574       P5OUT&amp;=~0x20;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel==24) {
<a name="l00577"></a>00577       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+3) |= 0x01;  
<a name="l00578"></a>00578       P2OUT|=0x02;
<a name="l00579"></a>00579     }
<a name="l00580"></a>00580   }
<a name="l00581"></a>00581   <span class="keywordflow">else</span> {
<a name="l00582"></a>00582     <span class="keywordflow">if</span> (channel&lt;8) {
<a name="l00583"></a>00583       *((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state) &amp;= ~(0x01&lt;&lt;channel);  
<a name="l00584"></a>00584       P1OUT=*((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state);  
<a name="l00585"></a>00585       P5OUT=0x08;
<a name="l00586"></a>00586       P5OUT&amp;=~0x08;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00587"></a>00587     }
<a name="l00588"></a>00588     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel&lt;16) {
<a name="l00589"></a>00589       channel-=8;
<a name="l00590"></a>00590       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+1) &amp;= ~(0x01&lt;&lt;channel);  
<a name="l00591"></a>00591       P1OUT=*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+1);  
<a name="l00592"></a>00592       P5OUT=0x10;
<a name="l00593"></a>00593       P5OUT&amp;=~0x10;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel&lt;24) {
<a name="l00596"></a>00596       channel-=16;
<a name="l00597"></a>00597       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+2) &amp;= ~(0x01&lt;&lt;channel);  
<a name="l00598"></a>00598       P1OUT=*(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+2);  
<a name="l00599"></a>00599       P5OUT=0x20;
<a name="l00600"></a>00600       P5OUT&amp;=~0x20;                                           <span class="comment">// clear the chip select bit</span>
<a name="l00601"></a>00601     }
<a name="l00602"></a>00602     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (channel==24) {
<a name="l00603"></a>00603       *(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) &amp;lla_state)+3) &amp;= 0xFE;  
<a name="l00604"></a>00604       P2OUT&amp;=0xFD;
<a name="l00605"></a>00605     }
<a name="l00606"></a>00606   }
<a name="l00607"></a>00607 }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 <span class="comment">/* ueaclib.c ends here */</span>
<a name="l00610"></a>00610 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Apr 20 13:56:24 2006 for uEACos by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
